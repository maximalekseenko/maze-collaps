# Разработка консольной игры на языке C++


## Идея
> На момент выбора темы курсовой работы я изучал принцип работы алгоритма wave function collapse, далее WFС и хотел попробовать имплементировать данный алгоритм.
>
> Это [указать пальцем на фото] Вернер Хейсенберг, предположительно, первый человек, написавший WFC.
>
> Вот [помахать рукой на картинки] результаты работы WFC.

[следующий слайд]

> Для чего нужен WFC?
> Самое частое применение алгоритма - процедурная генерация карт. В чем суть? Есть некое пространство точек, и каждая точка может принимать одно из возможных значений, к примеру "Лес", пусть "Море", "Гора", "Равнина". 
>
> И есть еще набор правил взаимодействий значений точек (к примеру "Гора" не может быть рядом с "Море", "Равнины" обязаны быть рядом с "Море").
>
> Алгоритм циклически проходит по всем точкам, каждый цикл выбирая новую точку с наименьшей энтропией, количеством возможних значений, и задает ей значение, далее смотрит как это повлияло на соседние точки.
> Вот [показать на первую картинку] он начал, добавил, и так далее...

[следующий слайд]

> Но разбираясь в принципах работы WFС, я наткнулся на интересное решение: 
> На вход расширенный алгоритм получает картинку, и разрезает её на все возможные пазлинки, и из этих пазлинок собирает новую картинку

[следующий слайд]

> Целью моей работы стало интерестно показать Wave Function Collapse.
>
> Интерестно - значит игрой, а в каких играх часто генерируется игровое поле? Правильно в играх жанра Rogue/Roguelike.

[следующий слайд]

## Игровое поле
> Так как идея игры пришла из генерации игрового поля - с него я разработку и начал.
>
> Это [показать на картинки поочередно слева на право] результаты работы алгоритма в разные этапы разработки. Вон [показать на первую картинку] сначала были погрешности, потом [показать на вторую картинку] их нет, [показать на третую картинку] и так далее.

[следующий слайд]

> Как сказанно было раньше, генерация игрового поля будет происходить с помощью алгоритма WFС и через поданную на вход картинку. Так же сгенерированная локация будет рекурсивной. То есть [показать на картинки] Картинка на вход: идешь влево - приходишь справа, и наоборот. То же самое и с картинкой на выходе.

[следующий слайд]

> Каждый уровень до генерации представляет из себя картинку и параметры алгоритма. Разные цвета пикселей на картинке обозначают разные тайлы: "Стена", "Пол", "Ловушка", "Спавнер"...
>
> И после генерации картинка превращается в игровое поле, населенное противниками.

[следующий слайд]

## Враги
> Соответственно следующим шагом было написание логики работы противников. 
>
> Чтобы противники были интуитивно понятны, шахматы были выбраны на данную роль. Из-за всеобщего понимания их передвижения. 
> Плюс у них есть символы в Unicode. А у меня игра консольная.

[следующий слайд]

> При написании врагов, я столкнулся со сложнастями
>
> Например, некоторые фигуры, такие как слон, ладья, по сути, не имеют лимита дальности хода, а локации у меня рекурсивные.
>
> Или пешка, правила движения которой в шахматах несколько перемудрены. Вобщем пешка ходит-бьет тольно по соседним клеткам.
>
> Король, который теперь бесполезен, призывает новые фигуры.

[следующий слайд]

> Алгоритм противников прост - он смотрит на ближайшие три хода и выбирает наилучший. Тем самым держа игрока в напряжении и страхе. Особенно перед слоном.
>
> Но противники могут потерять игрока из виду и начать спокойно блуждать по карте.

[следующий слайд]

## Игрок
> Игрок и его механики оказались самым сложным аспектом в процессе разработки.
> Но главным вдохновением было то, что шахматы в роли противников и замкнутые рекурсивно локации 
склоняют к тактическому геймплею.

[следующий слайд]

> В свой ход игрок может:
> * Передвинутся на соседнюю клетку, сбросив накопленные элементы
> * Накопить элемент. Если накопилось три элемента, игрок атакует.

[следующий слайд]

> Как работают элементы?
> В игре их три, и каждый имеет направление и тип урона
>
> От типа урона зависит кого может эта атака устранить
>
> За тип урона отвечает первый подготовленный элемент.
>
> Второй и третий (они обязаны быть одинаковыми) за напровление.

[следующий слайд]

## Интерфейс
> Визуальная составляющая была достигнута с помощью библиотеки <ncurses.h>

## Итог
> Мною была разработана консольная игра на языке С++.